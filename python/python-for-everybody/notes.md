# Chapter 2: Variables, expressions, and statements
- constants: value that doesn't change, e.g. `1`, `'hello world'`
- reserved words
- variables: named place in memory where data stored & retrieved later 
    - variables are assigned constants
        - e.g., `x = 12.1` can be said 'the variable `x`, using the assignment statement, is assigned to the constant `12.1`'
- mnemonic variable names
    - name variables to help remember what's meant to be stored 
    - keep in mind, python doesn't care about variable names and can't/won't interpret a difference based on the name assigned 
- assignment statement
    - evaluates the entire right side of the statement, then processes the left side 
- expressions
    - numeric expressions: +, -, *, /, ** (raise to power), % (remainder)
    - order of evaluation: follows PEMDAS + left to right for 'MD' and 'AS'
- type: difference between kinds of data 
    - concatenate: put together 
        - `+` between constants of the same type
    - type() [function]: check type of a constant or variable 
    - python3 division always provides a floating point number, regardless if the result could be an int 

# Chapter 3: Conditional Execution 
- comparison operators: <, <=, ==, >=, >, !=
- turn off tabs, and have IDE do 4 spaces instead of 1 tab
- `try` and `except`
    - anticipate when code might return a traceback and do something about it 
    - take a piece of code that might break, so `try` the code, and if it fails, then go to `except`
    - avoid overusing it; only put lines that could 'blow up' in it, and avoid multiple lines that could blow up to best nested within

# Chapter 4: Functions
- `def`: keyword to create function block
    - e.g. `def <function_name>(<optional_parameters>)`:
    - invoke function with `<function_name>()` and pass in necessary arguments 
- argument: value passed into function as its input when function is called
    - dynamically passed in when function is called 
- parameter: variable to use in function definition
    - statically defined when function is defined
- `return`: value that should be given after the function completes - the 'residual value' that occurs from the running of the function
    - better for a function to return a string rather than actually do the `print()`ing
- void functions: when a function doesn't return a value 

# Chapter 5: Loops & Iterations 
- `while` loop: (indefinite loop)
    - iteration variable: changes, so that the loop doesn't iterative forever 
    - zero-trip loops: not necessarily meant to run if the iteration variable is not the correct value 
    - `break` to get out of a loop. Continues to the line after the loop block 
    - `continue` says to finish the iteration and start at the top of the loop 
    - longer, more complex loops can be more challenging to see if a loop will be infinite 
- `for` loop: (definite loop)
    - runs a finite number of values, generally defined in a list 
    - `for <iteration variable> in <value>:`
    - manages the iteration variable without a bespoke statement incrementing it 
- loop idioms - how to construct loops 
    - making 'smart' loops
        - computers have to iterate once at a time. Have to figure out how to process the data, do something with it, and move on. Look at e.g. in ./python-for-everybody/exercise-5/largestNumber.py
- counting in a loop
    - examples of this and other counting functions are in ./exercise-5/counting.py
- `is`, `is not`
    - implies 'is the same as'; 'is not the same as'
    - similar to, but strong than ==
    - e.g. `0 == 0.0` returns `True`, `0 is 0.0` returns `False`
    - use `is` on booleans and `None` types

# Chapter 6: Strings
- string: sequence of characters 
- looking inside strings
    - can get at any single character in string using index specified in square brackets 
    - index must be integer and starts at zero
- `len()` (built-in function)
    - provides length of list 
- generally best to use `for` loop instead of `while` loop - for loops are more elegant
    - for decides when to run the loop & if it needs to keep being run
- slicing strings 
    - slicing says "up to, but not including"
        - e.g. `s = 'Monty Python' \ print(s[6:20])`
            - if the last number is larger than the number of characters in the list, then it grabs all the elements without producing an error 
- concatenation 
    - with the `+` in concatenation, no spaces are provided to strings
    - Using `,` to combine strings adds a space 
- using `in`
    - can be used as an operator in a string (outside of a loop)
    - treats the string as a list 
- string comparison
    - ==, <, > all work, although less than and greater than can be funky with differing cases 
- string libraries 
    - strings have built-in methods
        - `<string>.lower()` - doesn't change `<string>`; creates a new value
            - can be called directly on a string, or a string stored in a var 
        - call `dir(<string>)` to see all the built-in functions that can apply to the string/var 
    - `find()`: search a string - lists how many times value appears in string 
    - `replace(<search string>,<replacement string>)`: search & replace - replace all occurences of `<search string>` with `<replacement string>`
    - stripping whitespace (tab, newline, space)
        - `lstrip()`
        - `rstrip()`
        - `strip()`
    - prefixes
        - `startswith()`: returns True/False depending on what string starts w

# Chapter 7: Reading Files
- text file can be thought of as a sequence of lines that python processes through 
- opening a file
    - returns a 'file handle'
        - a wrapper; not the file itself or the data iteself 
    - `open(filename, mode)`
- `\n` newline character, important in file reading 
    - counts as a single character if `len()` is called on a str it is contained w/n 
    - every line in a text file ends with a newline, even if it's not visible 
- file handle as a sequence
    - file handle opened for read can be treated as sequence of strings
        - each line in the file is a string in the sequence
    - use for statement to iterate through the sequence of strings 
        - remember, sequence is an ordered set
        - "for each line in the file handle <file> do..." 
        - see ./chapter-7-files/countLines.py
            - reading the *whole* file in a single string
            - searching the file 