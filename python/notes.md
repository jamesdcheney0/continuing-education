# Introduction info
- string concatenation: when `+` is used on two string values 
- print() [function]: displays string value within parenthises 
- input() [function]: waits for user to type text and press enter. String can be added inside to inform user of what to type
- len() [function]: evaluates to the integer value of the number of characters in that string
- comparison operators [`==`, `!=`, `<`, `>`, `<=`, `>=`]: compare two values and evaluate down to a single Boolean value. 
- boolean operators [`and`, `or`, `not`]: used to compare Boolean values
    - [`and`, `or`]: always take two values
    - [`not`]: evaluates to the opposite Boolean value
    - evaluated `not`, `and`, `or`

# If statements 
- if [statement]: 
    - clause [the block following the if statement]: will execute if the statement's condition is `True`
    - else [clause]: executed only when the if statement's condition is `False`
    - elif [statement]: always follows if or elif. Provides another condition that is checked ONLY if any of the previous conditions were False. Once a statement condition is `True`, remaining `elif` or `else` are skipped 
- while [statement]: make a block of code execute over and over again
    - Code in clause will execute as long as while statement's condition is `True`
    - aka `while loop` or `loop`
- break [statement]: force program executation to break out a while loop's clause early
    - contains the `break` keyword 
- continue [statement]: program execution immediately jumps back to the start of the loop and reevaluates the loop's condition (by default, happens when execution reaches end of loop)
- for [statement]: execute a block of code only a certain number of times
    - combined with range(int) 
    - e.g. `for i in range(5)`
- import [statement]: must import modules before using them
- sys.exit() [function]: cause program to terminate by calling
- def [statement]: defines a function
- arguments: values passed into functions by typing them between the ()
- parameter: variable that an argument is stored in when a function is called
- return value: value that a function call evaluates to
- return [statement]: specify what the return value should be. Requires `return` keyword and value or expression that function should return
- None [value]: represents the absence of a value. `None` is the only value of `NoneType` data type. 
- keyword arguments: identified by the keyword put before them in the function call; generally used for optional parameters
    - e.g. `print('Hello',end='')` `end=''` is the keyword argument 
- global [statement]: can be used to modify the global variable from w/n a function
    - e.g., w/n function: `global eggs` \ `eggs = spam` to reassign global `eggs` var
- try [clause]: for exception handling. Put code that could potentially have an error a return and tab under `try:`
- except [clause]: second part of exception handling. On the same column as `try:`; contains code to handle what happens when error occurs 

# Lists 
- list [data type]: a value that contains multiple values in an ordered sequence
    - index() [list method]: can be passed a value, and if that value exists in the list, the index of the value is returned
        - e.g. `spam.index('moose')`
    - append() [list method]: adds argument to end of list
        - e.g. `spam.append('moose')`
    - insert() [list method]: insert a value at any index in the list. First argument is index for new value, second argument is new value to be inserted
        - e.g. `spam.insert(1, 'chicken')`
    - remove() [list method]: pass the value to be removed from the list it is called on
        - e.g. `spam.remove('chicken')`
    - del [statement]: delete values at an index in a list
        - `del spam[1]`
    - sort() [list method]: sort list of number values or lists of strings
        - `spam.sort(reverse=True)` to sort in reverse order
        - sorts in ASCIIbetical order (capital alphabet first, then lowercase alphabet (e.g. A, B, ... Z, a, b, ... z))
            - `spam.sort(key=str.lower)` to sort in alphabetical order
- list [value]: refers to the list itself 
- items [value]: values inside a list; separated by commas 
- index: Integery inside the square brackets that follows the list. Can only be integer values
    - index values start at `0`
    - `-1`: index value that refers to last index in a list
    - `-2`: index value that refers to second-to-list index in a list (and so on)
- slice: obtain several values from a list, in the form of a new list
    - e.g. `[0:2]`; typed b/w square brackets w two integers seperated by `:`
    - first integer: index where the slice starts
    - second integer: index where the slice ends; goes up to but will not include the value at the second index
    - shortcuts: leaving out first index is same as starting from beginning of list; leaving out second index is same as using the length of the list
- list concatentation and replication
    - `+` can combine two lists to create a new list value
    - `*` used w list and integer value to replicate list 
- for loops w lists: a for loop repeats the code block once for each value in a list or list-like value
    - can use `range(len(<list>))` w a for loop to iterate over the indexes of a list 
- in & not in [operator]: connect two values: a value to look for in a list and the list where it may be found. Evaluates to Boolean
    - e.g. `spam = ['hello','hi','howdy','heyas] \ 'howdy' in spam`
- multiple assignment trick: assign multiple variables with the values in a list in one line of code
    - e.g. `cat = ['fat','black','loud'] \ size, color, disposition = cat`
        - the three vars on the end would be assigned values from list cat. Both have to be the same quantity of values 
- augmented assignment operators [`+=`, `-=`, `*=`, `/=`, `%/`]: modify value and reassign to the same variable
    - e.g. `spam = 42 \ spam += 1 \ print(spam) \ 43`
- method: same thing as a function, except it is 'called on' a value
    - each data type has its own set of methods 
- tuple [data type]: typed with () and are immutable; cannot have their values modified, appended, or removed
    - to have only one value, place a trailing comma after the value inside the parenthese
- list() [function]: return a list of the values presented to it
- tuple() [function]: return a tuple of the values presented to it 
- reference: value that points to some bit of data
- list reference: value that points to a list
    - when assigning a list to a variable, actually assigning list reference to variable, not straight to the reference 
        - this means, by default what when modifying the original list (or dictionary), those changes would affect all lists based off that list (or dictionary)
            - copy.copy() [function]: to make a duplicate copy of a mutable value like a list or dictionary, not just a list reference
            - copy.deepcopy() [function]: if the list to copy contains lists that need to be copy, copy all of them (not their list references) with this function

# Dictionaries 
- dictionary [data type]: collection of many values using key-value pairs
    - keys() [dicionary method]: used to obtain keys from dictionary
    - values() [dicionary method]: used to obtain values from dictionary
    - items() [dicionary method]: used to obtain value and item pairs from dictionary 
    - get() [dicionary method]: takes two arguments, checks to see if a value is in a dictionary and if it's not, then a value to return when the expression returns False
    - setdefault() [dicionary method]: takes two arguments, the key to check for, and value to set at that key if the key doesn't exist
    - `dictionary[key] = value`: assign a value to a dictionary at the specified key 
- pprint [module]: helpful in pretty printing of dictionaries (among other things?)
    - pprint() [function]: pretty print a dictionary's values (e.g., newline between each dictionary value, and ASCIIbetically
    - pformat() [function]: obtain the prettified text as a string value instead of dictionary

# Manipulating Strings
- string values begin and end w a single quote
    - can begin and end w double quotes. W double quotes, `'` w/n string is ignored
- escape character: allow use of characters that are otherwise impossible to put into a string
    - `\'`: print `'`
    - `\"`: print `"`
    - `\t`: print tab
    - `\n`: print newline (line break)
    - `\\`: print `\`
- raw strings: place `r` before the beginning quotation mark of a string 
    - e.g. `print(r'That is Carol\'s cat.')` would return `That is Carol\'s cat.`
- multi-line strings: begins and ends w either three single quotes or three double quotes. Any quortes, tabs, or newlines between the triple quotes are considered part of the string
    - thus, using escape characters is optional in multi-line strings
- multi-line comments: can be made with a multi-line string; starting and ending with triple quotes
- strings use indexes and slices the same way lists do
    - if an index is specified, character at that position in the string will be returned
    - slicing a string does not modify original string
- `in` & `not in` operators can be used with strings just like w list values
    - e.g. `'Hello' in 'Hello world'`
## Useful string methods
- upper() [string method]: return a new string where all the letters in the original string have been converted to uppercase
- lower() [string method]: return a new string where all the letters in the original string have been converted to lowercase
    - e.g. `spam = 'Hello world!' \ spam = spam.upper() \ spam \ 'HELLO WORLD!'`
    - helpful to deal with user input and clean it up
        - e.g. `feeling = input() \ if feeling.lower() == 'great': \ ...` would be able to accept Great, GReat, etc and compare to `great`
- isupper() [string method]: return `True` if the string has at least one letter and all the letters are uppercase
- uslower() [string method]: return `True` if the string has at least one letter and all the letters are lowercase
    - otherwise, returns false 
- note: these methods do not change the string itself. Have to assign the method to the variable if wanting to preserve the change
- isalpha() [string method]: return `True` if the string consists only of letters and is not blank
- isalnum() [string method](stands for alphanumeric): return `True` if the string consists only have letters and numbers and is not blank
- isdecimal() [string method]: return `True` if the string consists only of numeric characters and is not blank
- isspace() [string method]: return `True` if the string consists only of spaces, tabs, and newlines and is not blank
- istitle() [string method]: return `True` if the string consists only of words that begin with an uppercase letter followed by only lowercase letters
- note: the isX string methods are helpful when needing to validate user input
- startswith() [string method]: return `True` if the string value begins with the string passed to the method
- endswith() [string method]: return `True` if the string value ends with the string passed to the method
- join() [string method]: join list of strings together into a single string value
    - called on a string, gets passed a list of strings, and returns a string
    - e.g. `', '.join(['cats','rats','bats']) \ 'cats, rats, bats'`
    - the string `join()` is called on is inserted between each string of the list argument
- rjust(), ljust() [string method]: returns a padded version of the string they are called on, with spaces inserted to justify the text
    - the first argument is the integer length of the justified string (includes the string, plus the amount of justification)
        - e.g. `'Hello'.rjust(10) \ '     Hello'` - Hello is five characters, so five spaces were added to the right
    - an optional second argument specified a fill character other than a space character
        - e.g. `'Hello'.rjust(10, '*') \ '*****Hello'`
- center() [string method]: centers the text, rather than justifying it
    - e.g. `'Hello'.center(20) \ '       Hello        '` - appears the higher number is put on the right side since the `20` can easily have `len(Hello)` subtracted from it 
- strip() [string method]: returns a string w/o any whitespace characters at the beginning or end
- lstrip(), rstrip() [string methods]: remove whitespace characters from the left and right ends, respectively
    - optionally, a string argument will specify which characters on the ends should be stripped 
        - e.g. `spam = 'SpamSpamBaconSpamEggsSpamSpam' \ spam.strip('ampS') \ 'BaconSpamEggs'`
        - the order of characters in the string passed to `strip()` doesn't matter
- pyperclip [module]:
    - copy() [function]: send text to clipboard 
    - paste() [function]: copy text from clipboard to use in program

# Regular Expressions
> Note: regex matcher at http://regexpal.com/ 

- Review of regex matching
    1. import regex module w `import re`
    1. create a regex object with the `re.compile()` function (remember to use a raw string)
    1. pass the string to search into the regex object's `search()` method which returns a `Match` object
    1. call the `Match` object's `group()` method to return a string of the actual matched text
- grouping w parentheses
    - adding parentheses will create groups in the regex
        - e.g. `phoneNumRegex=re.compile(r'(\d{3})-((\d{3}-\d{4})')`
    - `group()` [match object method]: grab matching text from just one group
        - e.g. `phoneNumRegex.search('My number is 719-421-9176').group(1)` 
        - or `mo = phoneNumRegex.search('My number is 719-421-9176') \ mo.group(1)`
        - both return `'719'`
    - `groups()` [match object method]: retrieve all the groups at once
        - e.g., from the above example, calling `.groups()` would return `('719', '421-9176')`
        - since `.groups()` returns a tuple of multiple values, the multiple-assignment trick can be used to assign each value to a separate variable
            - e.g. `areaCode, mainNumber = mo.groups() \ print(areaCode)` would return `415`
    - `|` (pipe): match one of many expressions
        - when both matches occur in the searched string, the first occurrence of matching text will be returned as the `Match` object
        - e.g. `heroRegex = re.compile(r'Batman|Tina Fey')`
        - or `batRegex = re.compile(r'Bat(man|mobile|copter|bat)')`
    - `?`: match zero or one of the group preceding; flags the group that precedes it as an optional part of the pattern
        - e.g. `batRegex = re.compile(r'Bat(wo)?man')` can match `Batman` or `Batwoman`
        - the group (in parentheses) indicates the optional part 
    - `*` (star, asterisk): match zero or more; the group that precedes the star can occur any number of times in the text
        - can be completely absent or repeated over and over 
    - `+` (plus): match one or more
        - group preceding a plus must appear at least once
    - `{}` (curly brackets): repeat a group a specific number of times - identified by an int w/n the brackets
        - instead of one number, a range can be specified by writing minimum, a common, and maximum b/w brackets
            - e.g. `{3}` and `{3,5}` are both valid
                - first one only matches three occurences
                - second one matches three to five occurences 
            - leave out first or second number in the brackets to leave max or min unbounded
                - e.g. `{,5}` or `{3,}`
    - greedy matching: default for python regex; in ambigous situations, will match for longest string possible
    - nongreedy matching: matches the shortest string possible
        - use a `?` after closing curly bracket to use nongreedy matching 
            - e.g. `{3,5}?` will prefer to get three matches from string, if possible 
    - `findall()` [match object method]: return strings of every match in the searched string 
        - if there are no groups in regex, returns a list of strings, not a `Match` object 
        - if there are groups in regex, returns a list of tuples
    - shorthand character classes
        - `\d`: match any numeric digit from 0 to 9
        - `\D`: match any character that is *NOT* a numeric digit from 0 to 9
        - `\w`: match any letter, numeric digit, or underscore character (think of this as matching 'word' characters)
        - `\W`: match any character that is *NOT* a letter, numeric digit, or an underscore
        - `\s`: match any space, tab, or newline character (think of this as matching 'space' characters)
        - `\S`: match any character that is *NOT* a space, tab, or newline
    - `[]`: define custom character class
        - e.g. `vowelRegex = re.compile(r'[aeiouAEIOU]')` will match any vowel, both upper and lower case
        - inside square brackets, normal regex syumbols are not interpreted as such; they are interpreted as raw - do not need to escape things
        - `^`: negative character class
            - will match all the characters that are *NOT* in the character class
            - e.g. `consonantRegex = re.compile(r'[^aeiouAEIOU]')` will match any consonant, upper or lower case 
    - `^`: indicate that match must occur at the beginning of the searched text
        - placed at the start of a regex
        - e.g. `beginsWithHello = re.compile(r'^Hello')`
    - `$`: indicate string must end with this regex pattern
        - placed at the end of a regex
        - e.g. `endsWithNumber = re.compile(r'\d$')`
    - memory aid: "carrots cost dollars" to recall order; caret comes first & dollar sign comes last 
    - `.` (dot): wildcard; will match any character *except for a newline*
        e.g. `atRegex = re.compile(r'.at') \ atRegex.findall()('The cat in the hat sat on the flat mat.')` returns `['cat', 'hat', 'sat', 'lat', 'mat']` - 'flat' only returned `'lat'` because only one wildcard was included
    - `.*`: match everything and anything
        - uses greedy mode by default; it will always try to match as much text as possible
        - e.g. `nameRegex = re.compile(r'First Name: (.*) Last Name: (.*)') \ mo-name.Regex.search('First Name: James Last Name: Cheney') \ mo.group(1)` returns 'James'
        - `(.*?)` to use nongreedy mode 
    - `re.DOTALL`: second argument to use w `re.compile()`; make the dot character match *all* characters 
    - `re.IGNORECASE` | `re.I`: second argument to use w `re.compile()`; make regex case-insensitive
    - `sub()` [method]: subtitute new text in place of regex patterns
        - passed two arguments
            - string to replace any matches
            - string for the regex
        - e.g. `namesRegex = re.compile(r'Agent \w+') \ namesRegex.sub('CENSORED', 'Agent Alice gave the secret documents to Agent Bob.')` returns `'CENSORED gave the secret documents to CENSORED.'`
        - can use matched text itself as part of the substitution
            - in the first argument of `sub`, type `\1`, `\2`, `\3`, etc to mean 'enter the text of group 1, 2, 3, etc in the subtitution
            - e.g. `agentNamesRegex = re.compile(r'Agent (\w)\w*') \ agentNamesRegex.sub(r'\1****', 'Agent Alice told Agent Carol that Agent Eve knew Agent Bob was a double agent.')` returns `A**** told C**** that E**** knew B**** was a double agent`
                - `(\w)\w*` matches the first character in the agent name in the group `(\w)`, and captures the rest of the letters in the agent name with `\w*`, which cuts off when it encounters spaces
                - `\1****` takes the match from the first group - the first letter of the agent's name - and replaces the name in the original string with the first letter and four asterisks
    - `re.VERBOSE`: tell `re.compile()` to ignore whitespace and comments inside the regex string
        - this allows the use of multiline comments
        - trunkated e.g.: `(r''' (#text and newlines)''',re.VERBOSE)`
    - by default, `re.compile()` can only take one value as second argument. Get around this limitation by combining `re.DOTALL`, `re.IGNORECASE`, and `re.VERBOSE` with `|`
        - e.g., `someRegexValue = re.compile('foo', re.IGNORECASE | re.DOTALL | re.VERBOSE)`

## Review of regex symbols
- `?`: match zero or one of preceding group
- `*`: match zero or more of the preceding group
- `+`: match one or more of the preceding group
- `{n}`: match exactly `n` of the preceding group
- `{n,}`: match `n` or more of the preceding group
- `{,m}`: match 0 to `m` of the preceding group
- `{n,m}`: match at least `n` and at most `m` of the preceding group
- `{n,m}?` or `*?` or `+?` performs a nongreedy match of the preceding group
- `^spam`: string must begin with `spam`
- `spam$`: string must end with `spam`
- `.`: match any character, *except newline characters*
- `\d`, `\w`, `\s` match any digit, word, or space character, respectively
- `\D`, `\W`, `\S` match anything *except* a digit, word, or space character, respectively
- `[abc]`: match any character between the brackets - in this case, `a`, `b`, or `c`
- `[^abc]`: match any character that *isn't* between the brackets 

# Reading and Writing Files
- os.path.join() [function]: pass string values of individual file and folder names in path & string of file path using correct path separators returned
    - .e.g. `os.path.join('usr','bin','spam')` would return usr/bin/spam on macOS
    - helpful to create strings for filenames
- os.getcwd() [function]: get current working directory as string value
- os.chdir() [function]: change current working directory
- absolute path: always begins w root folder
- relative path: relative to the program's current working directory 
    - `./` at the beginning of a relative path is optional
- os.makedirs() [function]: create new directories with python
    - will create any necessary intermediate folders to ensure full path exists 
- os.path [module]: contains functions related to filenames and file paths
- os.path.abspath(path) [function]: return a string value of absolute path of argument
    - easy way to convert a relative path into an absolute path
- os.path.isabs(path) [function]: will return `True` if argument is an absolute path and `False` if not
- os.path.relpath(path, start) [function]: returns string of relative path from the `start` to `path`
    - if start not provided, current working directory is used as start path
- os.sep [variable]: set to the correct folder-separating slash for the computer running the program
- os.path.dirname(path) [function]: return a string of everything that comes before the last slash in the path argument
    - collects directory information from file path
- os.path.basename(path) [function]: return a string of everything that comes after the last slash in the path argument
    - collects file name/extension from file path
- os.path.split() [function]: get a tuple value of os.path.dirname() and os.path.basename()
    - note: split does not take a file path and return a list of strings for each folder 
        - to do that (like how the os.path.join works, but in reverse), use split() string method and split on the string in os.sep
- os.path.getsize(path) [function]: return size in bytes of file in path argument
- os.listdir(path) [function]: return a list of filename strings for each file in the path argument
    - note: this function is in the os module, not os.path
- os.path.exists(path) [function]: return `True` if file or folder in path argument exists and `False` if not
- os.path.isfile(path) [function]: return `True` if path argument exists and is a file and `False` if not
- os.path.isdir(path) [function]: return `True` if path argument exist and is a folder and `False` if not

## File Reading and Writing
- open() [method]: pass a string path indicating file to open
    - can be either absolute or relative path
    - returns a `File` object
    - e.g. `helloFile = open('/Users/jamescheney/spam/spam/eggs/spam/spam.txt')`
    - opens the file in 'reading plaintext' mode (aka read mode)
        - can explicitly specify read mode with a second argument of `r`, but it is the default mode
        - cannot write to a file opened in read mode
- read() [method]: returns string of what is stored in the file that `open()` was performed on
    - e.g. `helloFile.read()`
- readlines() [method]: get a list of string values from file - one string for each line of text 
- write mode: overwrite existing file and start from scratch
    - pass `w` as the second argument to `open()`
- append mode: append text to the end of existing file
    - pass `a` as the second argument to `open()`
- if filename passed to open() does not exist, write and append mode will create new, blank file
- close() [method]: after reading or writing a file, call the `close()` method before opening the file again 

## Saving Variables with shelve Module 
- shelve [module]: save variables in Python programs to binary shelf files
    - enables program to restore data to variables from the hard drive
    - `import shelve` to read & write data using `shelve` module
- shelve.open() [function]: pass it a filename argument and store returned shelf value in a variable
    - can make changes to shelf value as if it were a dictionary
- close() [function(?)]: save changes to shelf value and close
- shelf values can be read and written once opened 