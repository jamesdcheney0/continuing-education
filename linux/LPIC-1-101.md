# Introduction to Linux 
- Torvalds is still a significant project manager 
- advantages
    - linux scalability feeds cloud computing
    - physical infrastructure control
    - open source + infinitely customizable
    - cost effective
    - security & reliability
    - technical support 
## Introduction to the LPIC and AWS
- LPIC-1 Linux Service Professional Certification
    - provision & manage servers + PCs
    - requires two $183 exams: LPI 101 & LPI 102
- LPIC-2
    - administer small to medium-size mixed networks
    - two exams LPI 201 & 202
- LPIC-3
    - take one of three exams 
        - 300: Mixed Environments
        - 303: Security
        - 304: Virtualization and High Availability
- LPIC certs good for 5 years
- Linux and AWS
    - most new IT is cloud-based
    - most cloud resources built on Linux
    - AWS is world's largest public cloud provider 
## LXCs: the safest way to learn Linux skills 
- LXC container: use as a sandbox for learning on linux systems
- probably better to just use docker on my local machine 
    - `docker run -it ubuntu /bin/bash`
    - `docker run -it alpine sh` 

# Linux System Architecture
## Identifying Hardware Peripherals 
- everything under /proc is under sysctl;
- everything under /sys under sysfs
    - newer fs that relies heavily on simlinks 
- under /dev, specific hardware devices are listed 
- info about physical devices are under /sys/class/ and /proc/sys/dev. /dev contains symbolic links to physical devices 
- linux kernel: core of the OS
    - to extend kernel's control, indivdual modules can be added and removed 
    - dbus message bus system 
- system management tools
    - init: in the beginning, served as air traffic control
        - can only control actions synchronously
    - Upstart: replaced init in 2006
    - systemd: replaced Upstart in 2015
## Managing Hardware Peripherals
- modules for most peripherals already installed in the os 
    - `lsmod` to list all modules in OS 
        - `lsmod | grep lp` to find all instances of the specific module 'lp'
        - `sudo modprobe -r lp` to remove the module 'lp'
            - can use `rmmod <module-name>` to remove module 
        - `sudo modprobe lp` to install module 'lp'
            - can use `insmod <module-name>` to install a module
    - `/lib/modules` is where all available modules on local machine are 
        - dirs are named after linux kernel releases 
            - older versions of the kernel and hardware modules are saved 
            - `uname` or `uname -r` to list OS and kernel version
        - list all available modules `find /lib/modules/$(uname -r) -type f -iname "*.ko"`
- udev: linux dynamic device management 
    - rules locations 
        - `/etc/udev/rules.d`, `/run/udev/rules.d`, `/usr/lib/udev/rules.d`
            - read in that order 
        - file names include a number at the beginning to indicate the importance to read them. Lower value = higher preference 
- device naming (all managed by udev)
    - network interfaces: eth0, eth1, em0, em1, ...
    - hard disk drives (also SSD): sda, sdb, ...
        - partitions: sda1, sda2, sda3, ...
    - floppy drives: fd0, fd1, ...
    - CDRom/DVD drives: sr0, sr1, ...
    - `dmesg` to see current devices messages 
- aws instance metadata
    - `curl http://169.254.169.254:latest`
## How Linux Boots Your Computer
- BIOS (Basic Input/Output System)
    - performs hardware inventory
    - loads MBR (master boot record) into system memory
- MBR
    - uses the first 512 MB of HD
    - contains partition and filesystem information
- GRUB (Grand Unified Bootloader)
    - executes kernel
- kernel
    - loads temporary initrd image
    - mountas root partition and starts init (/sbin/init)
- init
    - uses SysVinit, Upstart, or systemd executes appropriate run level
- run level
    - executes running 
    - controls user login
    - available run levels
        - 0: halt (`/etc/rc0.d/`)
        - 1: single user mode (`/etc/rc1.d/`)
        - 2: multiuser, w/o NFS (`/etc/rc2.d/`)
        - 3: full multiuser mode (`/etc/rc3.d/`)
        - 4: unused (`/etc/rc4.d/`)
        - 5: X11 (`/etc/rc5.d/`)
        - 6: reboot (`/etc/rc6.d/`)
## Managing and Troubleshooting the Boot Process
- force GRUB menu to show up with clicking right shift key repeatedly, or hold power button for 5 seconds during boot, and it will come up next time 
- able to boot to other kernels in GRUB
- to launch root shell session, in the text editor (press e key) can add `rw init=/bin/bash` to be able to work in an otherwise unbootable machine 
- access recovery in advanced settings 
- `/var/log` can be accessed through a variety of means of the GUI won't come up
    - `cat dmesg | grep "<string to search for>"` to search dmesg log for a specific string 
    - `less dmesg` to search through for string in context 
- AWS also provides 'instance settings > get system logs' and look for errors there 
## Linux Run Levels and Boot Targets 
- init `/etc/inittab` file contains init runtime info
- Upstartd stores runtime info in `/etc/init/rc-sysinit.conf` file 
    - `env DEFAULT_RUNLEVEL=2` is an example of the line that sets it 
- systemd doesn't directly focus on run level, but on unit processes 
    - manually manage units in `/etc/systmd/system`, and packages in `/usr/lib/systemd/system`
    - `systemd-analyze` lists in seconds how long each process in the startup process took 
        - `systemd-analyze blame` lists in milliseconds how long each service took to come up 
    - `systemctl list units` lists info about all running units 
        - use grep to narrow down results `systemctl list units | grep home_mount` 
        - `systemctl list-units | grep httpd` to see if httpd running
        - `systemctl enable httpd.service`
        - `systemctl start httpd.service` to start right away
    - manages the following through files in `/etc/systmd/system` and `/usr/lib/systemd/system`
        - services (.service)
        - mount points (.mount)
        - devices (.device)
        - sockets (.socket)
- `sudo telinit 0`, `sudo shutdown` to stop immediately 
    - `sudo shutdown -h 2` to shutdown in two minutes or `-r` to restart 
- can use `wall` to output text to other users logged into machine 
    - `cat text | wall` 

# Boot and Package Management
## Boot and Hardware Management
### Partitions and Filesystems
- partitions
    - balance separation and accessibility
    - organize data and filesystems 
    - partition of a disk drive that has been walled off from others on the drive 
    - can also make multiple types of media appear on the same mount to the user 
- mount: extend filesystem accessibility 
- directory categories
    - /home (usually w / and /proc, etc, or sometimes off by itself)
    - / (root)
    - /proc, /dev, /sys
    - /boot (for the MBR)
    - SWAP (when running out of RAM) (file system is actually 'linux-swap')
- it's best to right-size partitions. It's possible to increase partition size, but also risky
- `lsblk` to list block device information
- logical volume manager (LVM)
    - can manage any volumes together as one
    - PV: physical volumes
    - VG: volume group (collection of one or more PVs)
        - e.g. `sudo vgcreate my-vg /dev/sdb2 /dev/sdb3`
    - LV: logical volume (created from a VG)
        - e.g. `sudo lvcreate -L 250G -n my-lv my-vg`
    - `sudo lvscan` to view volumes 
### Working with a boot manager
- (on fedora) `rpm -q grub2` to check to see if GRUB2 is installed 
    - `grub2-install /dev/sda` (define the partition to install it in)
    - /boot/grub (or grub2 on fedora)
    - /etc/grub.d: files defining available OSs
    - /etc/default/grub: sets default settings for grub 
    - update /boot/grub2/grub.cfg (on fedora)
- boot repair: linux package that will fix a broken boot loop (need physical access to machine)
### Working with shared libraries 
- with libraries, developers can have their programs call local libraries and not have to reinvent the wheel every time 
- static libraries
    - read when initially installed
    - may cause the program to run slower, but able to run standalone 
- dynamic libraries
    - available throughout the lifetime of a software package
    - much leaner & faster tools possible
- libraries (aka dependencies) established when app installed 
- libraries live in `/lib` 
    - file begins with lib indicating it's a library
    - next few characters identify what library
    - .so indicates it's static (.a indicates static)
    - after so, library version is listed
    - libraries often built on other libraries 
    - /etc/ld.so.cache is read by the machine when checking for libraries 
    - /etc/ld.so.conf human readable
    - `ldconfig` lists all libraries installed 
        - `-p` will list all available libraries 
    - `ldd`: display dependencies and file locations 
## Linux Package Management
### Debian Package Management
- dpkg (.deb)(apt)
    - distribution: Debian, Ubuntu
    - /etc/dpkg/dpkg.cfg contains dpkg defaults 
    - `sudo dpkg -i <package>.deb` to install 
    - `sudo dpkg -r (or -P to purge) <package>` to uninstal
    - `sudo dpkg --unpack <package>` to unpack but not install 
    - `sudo debconf-show <package>` to view configuration 
    - dpkg is for local installs 
- apt for accessing internet-available packages 
    - main/universe/multiverse
    - update `/etc/apt/sources.list` to point to new repositories 
    - `apt-get update` to update upstream package info
    - `sudo apt-get install <package>` to install packages
    - `sudo apt-get [upgrade|dist-upgrade]` to upgrade packages 
    - `sudo apt-get remove <package>` to remove package
    - `apt-get install -s <package>` to get package information 
    - `apt-cache stats|depends|unmet <package>` to get statistics, dependencies, or unmet dependencies of packages 
- aptitude
    - CLI tool, kinda like vi. not GUI-based 
- synaptic: GUI-based desktop package manager 
### RPM/YUM Package Management
- RPM (.rpm)(yum)
    - distributions: Red Hat, Fedora, openSUSE
    - naming structure: app, version, architecture, .rpm 
    - `sudo rpm -i <package>`
    - `sudo rpm -U <package>` also installs 
    - `sudo rpm -q httpd` to query
    - `sudo -i --test <package>` to return package's dependencies 
    - `rpm -K <package>` to get checksum of package
    - `rpm -V <package>` to verify package (lower case -v for verbose)
- yum 
    - `/etc/yum.repos.d`, `/etc/yum.conf`
        - contains repository info & has different files for different types of apps 
        - contains pointers to repo sources 
    - `sudo yum install <package>` to install 
    - `sudo yum update`
    - `sudo yum remove`
    - `yum search <package>` to search for installed app
    - `yum list | grep <search term>` to look for specific app
    - `yumdownloader --resolve <package>` to let yum resolve dependencies 
    - `rpm2cpio <package> | cpio -id` restore archive and make directories as needed 
- AWS
    - `/etc/yum.repos.d` contains AWS-specific repo pointers on amazon linux images 

# CLI Basics
## Working With Text Strings
### Working on the Command Line
- CLI is a command language interpreter
- every command line is a shell; independent compute environment with its own rules
- bash (bourne again shell)
    - typing `sh` will create a sh shell (different than bash)
    - bash scripts: executable text files 
- echo: output text to next line 
    - text after $ will tell echo to look for a variable
    - bash is very case sensitive
- `set` output list of all system variables
- `env` will only output environment variables; will not include functions & won't include variable unless exported to environment 
    - `export <variable>`
- `name=value` to create new shell variables 
- `unset <value>` to remove shell variables 
- `pwd` current work directory
- `uname -a`: output linux kernel version & current date + time 
- `man <command>` returns a manual with the use and function of command
    - nine page types
        1. executable programs or shell commands
        2. system calls (functions provided by the kernel)
        3. library calls (functions w/n program libraries)
        4. special files (usually found in /dev)
        5. file formats and conventions e.g. /etc/passwd
        6. games
        7. miscellaneous (including macro packages + conventions)
        8. system administration commands (usually only for root)
        9. kernel routines 
- `man bash` tells all about how bash works 
    - can be searched with `/`
- `apropo <search term>` to look for apps that might be related to a term, e.g. `apropo copy` to look for all apps related to copying things
- `history` show commands in reverse order
    - `.bash_history` contains what history outputs and can be edited
### Process Text Streams Using Filters
- `cat <filename>`: print to screen 
    - short for concatenate 
    - `-n` will print line numbers
- `cut -d: -f1 <filename>`: print a single column of text
    - `-d:`: field delimiter of colon 
    - doesn't change contents of file, but could pipe the results (with `>`) to a new file 
- `expand <filename>`: convert tabs to spaces
    - `-t X` where X is the number of spaces each tab is replaced with 
- `unexpand <filename>`: convert spaces to tabs
    - `-t X` where X is the number of tabs each space is replaced with 
- `fmt -w 60 <filename>`: format line width
    - `-w X` force newline every X number of characters 
    - `-t` indent all paragraph lines after the first line 
- `pr -d -l X <filename>`: format line spacing
    - `-d` doublespace 
    - `-l X` limit of total lines 
- `head -X <filename>`: print first X lines of a file
- `od <filename>`: print characters in various formats 
    - 'octal dump' 
- `less` (or `more`): display text files by screen
    - can use arrow keys or pg up/down to move 
- `join <filename1> <filename2>`: merge columns from multiple files, if they share common fields 
- `paste <filename1> <filename2>`: print multiple files
    - will print data from each file side by side
    - `-s` will print data sequentially rather than side by side 
- `nl <filename>`: print a file w line numbers
- `sort -nr <filename>`: control print order
    - reorder contents of file by alphabetical, and reverse alphabetical with `-r`
    - `-n` numerical, opposite with `-nr`
- `split -X <filename>`: split file into smaller files
    - performs permanent actions by default 
    - X = number of lines in each line 
- `tail -n 3 <filename>`, `tail -f /var/log/syslog`: prints or monitor the end of a file
    - `-n` just the end of the file
    - `-f` lists the current end of the file and scrolls by 
- `tr "a-z" "A-Z"`: translate text formatting
- `uniq -u <filename>`: isolate duplicate entries 
    - will only print unique lines 
- `wc filename`: display document statistics
    - total number of lines, words, bytes of file 
- `sed s/dog/"horse"/`: substitute text strings
    - sed: stream editor 
    - LPI doesn't cover it much, but there's obviously much to dive into 
    - `sed s/dog/d` to delete the string in question 
### Perform Basic File Management
- `mkdir -p /path/to/dir` to make child dir and any requesite parent dirs 
- `cp -r newplace/ /path/to/dir` to copy all files in the second directory to the first directory (recursive) 
- `file <filename>` will provide additional information on files
- `rm` generally does not ask for confirmation before deletion
    - `-i` will ask before deletion 
    - `rm file?` will delete any files with name `file` and an additional character - e.g. file1, filea - but not file12
    - `rm file*` will delete any file with name starting with file
- 'globbing'is the technical term referring to the ability of `?` and `*` to pick up multiple files at once 
- tar
    - `tar -cvf /path/to/dir *`
        - `-cvf` create verbose file
        - create new archive in the specified directory with all the files in the current directory 
        - add `z` to compress as well 
        - `-A` to append files to existing archive 
    - expects name of archive to immediately follow after f switch 
    - `-x` to extract 
- gzip, gunzip, bzip2, xz are all types of archiving 
- `ls | cpio`
    - cpio usually used in conjunction with a | 
    - `ls | cpio -o > lsarch.cpio` to create archive of files in current dir 
    - `ls | cpio -o | gzip > lsarch.cpio` to compress the archive 
    - example to use find to pipe data to cpio
        - `sudo find ./ -maxdepth 4 -name "*.txt" | cpio -o /home/ubuntu/findarch.cpio`
- dd (coloquially disk destroyer)
    - `dd if=/files/to/copy of=/destination/dir
    - able exactly copy a directory in another place 
### User Streams, Pipes, and Redirects
- all dataflows are one of three file descriptors
    - stdin: standard input: 0
        - data input into program
    - stdout: standard output: 1
        - data output from program 
        - e.g. `tail /etc/log 1> log-data.txt` to send the standard output to the `log-data.txt` file (technically don't have to use 1, since that's the default anyway)
    - stderr: standard error: 2
        - e.g., instead of outputting failure of command to cli, can output to a file with `cat doesntexist 2> errors` 
- can save output of ls to a file with
    - `ls -l | tee list.txt` and it will list the dir, and put that output into the file list.txt
- redirect stream with `>`
    - overwrite `>`
    - append `>>` 
## Working With Processes
### Create, Monitor and Kill Processes
- `ps aux` display useful information about live programs
    - user, process id, percentage of resources used, command used to launch process 
    - `ps aux | grep program`
    - `pgrep -u root sshd` look for program ID for sshd started by root 
- `free` lists available memory 
    - `free -h` for more human readable
- `uptime` length since last time server was booted 
- `top` check which resources are using what resources
    - until `q` is pressed, will continually update 
- `killall <app>` or `kill <PID>` to forceably kill programs 
    - process kill signals 
        - sighup: 1: hangup
        - siginit: 2: interrupt (like a ctrl-c in the process)
        - sigkill: 9: force kill
        - sigterm: 15: immediately terminate
        - running w no signal code defaults to sigterm
    - `pkill <program>` closes down a process that is near what the program is. E.g. `pkill ssh` will kill sshd 
- screen
    - `screen` to launch new screen
    - ctrl + a + w: lists window bar at the bottom that identifies current session
    - ctrl + a + d: detach 
    - `screen -ls` to list currently running screens from outside of screen
    - `screen -x` attach to live screen 
    - ctrl + a + c: new window
    - ctrl + a + S: split in half horizontally 
    - ctrl + a + tab: move b/w screen 
    - ctrl + a + \: escape and kill screen session 
- by default, every program takes over the shell when it starts 
    - can run an operation in the background by appending `&` at the end 
    - bring job to foreground w `fg <job-id>`
    - ctrl + z, then `bg <job-id>` to put it back in the background 
    - `jobs` to display status of current jobs
    - `ps` will run all processes running in current shell 
    - `nohup` before a command will tell the command to continue even if the shell is closed 
### modify process execution properties 
- nice priority values 
    - default: nice 0: PR 20: no process priority
    - high nice value: nice 19: PR 39: process priority low 
        - process is being 'nice' to everyone else, and gives its resources to every other program first 
    - low nice value: nice -20: PR 0: process priority high 
    - can add `nice -10 <command>` to *increase* the nice rating. "dash 10" not "minus ten"
        - `nice --10 <command>` would decrease the nice rating to "minus 10"
        - `renice -10 -o <PID>` would change the nice value to *"minus 10"*
            - to change nice value of a user, `renice 10 -u ubuntu` which would make the ubuntu user more nice, and thus get fewer resources 
            - `renice 10 -g <group-name>` to give a whole group a different nice value 
- `ps -elf | grep <program>` to get PID for specific processes 
## Search and Text Editors 
### Search Text Files Using Regular Expressions
- regex metacharacters: . [ ] ^ $ \ *
- grep: global regex print
    - `grep "b\(an\)\+a" <file>` to search a file for a b, followed by any number of 'an' ending with 'a' [to find banana]
        - or `egrep "b(an)+a" <file>` to use extended grep to do the same thing 
    - fgrep (or grep -f) ignores processing special characters and looks for the literal appearance of them in files
        - `fgrep "dkis,$eiv" <file>` to look for a password that might be exposed 
    - instead of `cat /var/log/dmesg | grep sdb1` to look for a drive mentioned in the logs
        - `grep sdb1 /var/log/dmesg` to provide the same results 
        - `grep -r sdb1 /var/log/dmesg` to search recursively below the defined dir 
        - `grep -v 3 /var/log/dmesg` to exclude lines which include "3"
            - `grep -vn 3 /var/log/dmesg` to exclude lines which include "3", and also include line numbers in the output 
### Perform Basic File Editing Operations Using VI
- vi modes: normal (command) mode, insert mode, command line mode 
- command line mode operations
    - :w (save a file)
    - :exit or :wq to exit vi
    - :q close vi w/o saving
- command mode
    - dw (delete one word to right)
    - d$ (delete to the end of the line)
    - dd (delete entire line)
    - p (paste)
    - u (undo)
    - yy (copy line)
    - ZZ (save and exit)
    - h (move to the left)
    - l (move to the right)
    - j (move down)
    - k (move up)

# Linux Partitions and Filesystems
## Filesystems
### Creating Partitions and Filesystems
- partitioning schemes 
    - MBR: master boot record
        - limitations: four partition maximum, two tb max
    - GPT: GUID partition table
        - doesn't always work with BIOs (in windows 8.1 only worked with UEFI)
- `fdisk` from MBR, and doesn't support GPT
    - `fdisk <disk>` will get into the command line for fdisk
    - distracted partition editing can be extremely destructive 
    - p: list existing partitions 
    - l: list partitions types
    - n: new partition 
    - t: set partition type
    - w: write partition changes 
    - q: exit 
- `parted`
- `gdisk` more closely copies fdisk, and work with GPT partitions 
- `mkfs -t ext4 /dev/sdc`
    - make filesystem of type ext4 on drive /dev/sdc 
    - `df -h` to view all partitions associated with system 
        - if in doubt, double check
- filesystems
    - ext2: linux: no journaling
    - ext3: linux: journaling 
    - ext4: linux: journaling, 16TB files
        - journaling: records file system changes to make recoveries from crashes easier
    - Reiserfs: linux: journaling, stable
    - Btrfs: linux: no journaling, stable, fast 
    - XFS: linux: journaling, 64-bit, large files
    - VFAT: extention of FAT32: windows 
### Maintain Filesystem Integrity
- `df -h` list all active partitions on system by name & list in human-readable form
    - `-ih` i-node use
    - `-T` list disk types 
- `du -h` disk usage of current disk and all directories below it
- `du -s` reveals the overall total 
- `dumpe2fs <volume>` to list useful info about the volume 
- `tune2fs -c 40 -i 1m /dev/sda1`
    - check 40 mounts every 40 minutes on /dev/sda
    - `tune2fs -L new-name /dev/sda1` to set a new label for file system 
    - sets number of mounts before checks 
    - `sudo tune2fs -j /dev/sda1`
        - add journaling to ext2 filesystem
- `fsck /dev/sdc1`
    - correct filesystem problems 
    - `fsck` can be run after disk is unmounted `umount`
- `e2fsck` used to correct ext* filesystem problems 
- `debugfs /dev/sda1`: file management on filesystem 
### Control Filesystem Mounting and Unmounting
- mount point: 'address' that OS can consistently find the device 
- `lsblk` to find drive information
- `mount /dev/sdc1 usb-drive/` to mount a USB drive to a directory in the current folder 
- `umount` to unmount 
- `fstab` read on boot up, and if `umount -a ...` is ran
    - entries remain during reboot
    - to keep drive mounted every boot, have to add to fstab
## Manaing Files and Disk Space
### File Permissions and Ownership
- permissions representations 
    - character: read: r; write: w; execute x
    - octal: read 4; write 2; execute 1
    - user classes: owner u; group g; other o
- d at beginning of the results in `ls -l` indicates its a directory
- first triad is for owner, second for group, third for other 
- number after the permissions representation number of hard links to object
- owner listed next (`chown` to change user/group)
- group listed after (`chgrp` to only change group)
- `chmod` to change permissions for an object 
    - can use octal or character
        - `chmod o-w`, `chmod o+w` to remove or add write to other
- SUID: can make a user temporary owner of a file to allow them temporary additional permissions 
    - `rws` in the triads indicates when the program is run (e.g. passwd)
    - `chmod o+s` to add it to the owner triad 
    - has a value of 4
- sticky bit: protects file in shared dir from being deleted by others 
    - can be added w `chmod -t <filename>` or `chmod 1775 <filename>`, apended before the usual octal value 
- `umask`: default value new file or directory will receive when it's created 
    - represented as total octal value (777) minus its actual value
        - e.g., if octal value is 755, umask would be 0022 
    - `umask 0022` to change permissions for file creation in current shell (lost when shell is closed)
### Linux File Locations
- filesystem layout
    - files generally remain in the same locations between linux distributes 
    - FHS: filesystem hierarchy standard 
    - /bin: basic system binaries
    - /boot: files to get os up and running
    - /dev links for hardware devices
    - /etc: text-based config files 
    - /home: user's personal files & dirs
    - /lib: code libraries
    - /media, /mnt place to mount external devices
    - /opt: program installation files
    - /proc: pseduo file-system representing processes
    - /root root user's home dir
    - /run: run time data storage (will not survive boot)
    - /sbin: system binaries
    - /srv: site-specific data (e.g. for local web server)
    - /sys: not part of FHS, but contains system hardware info
    - /tmp: temp system files (will not survive boot)
    - /usr: application files 
        - /bin: global binaries
        - /lib: libraries
        - /sbin: system binaries
        - /share: shared app data
        - /src: application source code 
    - /var: 
        - /cache: application cache
        - /lib: state information
        - /log: system logs
        - /mail: mailboxes 
- searching for files
    - `sudo find /etc/ -name *.conf` search /etc for all files ending in .conf 
    - `sudo find / -name fstab` to search everywhere for 'fstab'
    - `locate fstab`
        - reads a db that's updated with file information, rather than searching whole system
        - `sudo updatedb` to update the db it reads from 
    - `whereis <program>` to find location of app
    - `which <program>` 
- linking files 
    - symbolic links (symlinks): retain separate inodes & keep changes synced 
        - deleting the parent removes the link 
        - `ln -s /path/to/existing/file /path/to/sync/location`
        - can be viewed with `ls -l` and starts with an `l`
    - create hard link
        - both use the same inode
        - `ln /path/to/existing/file /path/to/sync/location`
### Manage Disk Quotas 
- set disk space limits for users or groups 
- `sudo yum install quota` 
- edit /etc/fstab to add usrquota, then reboot 
- `sudo quotacheck -avmug`: build quota environment
- `sudo quotaon -av`: enable quota controls 
- can set block limits or file limits 
    - hard and soft limits 
        - hard limit, if something tries to get added &* would take over the limit, operation denied
        - soft limit, if file is added & goes over the limit, the excess is allowed, but only for a specified period of time. By default, 7 days
- `edquota -u` to affect users, `edquota -g` to affect groups, `edquota -t` to affect grace period 